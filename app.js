// State to store user selections and data
let state = {
  methodsData: null,
  categories: [],
  userSelections: {},
  filteredMethods: []
};

// Define hierarchical categories with specific logic
const HIERARCHICAL_CATEGORIES = [
  'level_of_cultural_permissiveness',
  'political_sensitivity_regarding_empowerment_of_adolescent_girls',
  'participant_access_to_technology',
  'financial_resource',
  'human_resource_skills'
];

// Special category with custom hierarchy
const POLITICAL_STABILITY_CATEGORY = 'level_of_political_stability';

// Function to get hierarchical values for a selection
function getHierarchicalValues(category, selectedValues) {
  // Handle political stability with custom hierarchy
  if (category === POLITICAL_STABILITY_CATEGORY) {
    const expandedValues = new Set();
    
    selectedValues.forEach(value => {
      if (value === 'Conflict-affected') {
        expandedValues.add('Conflict-affected');
        expandedValues.add('Fragile');
        expandedValues.add('Stable');
      } else if (value === 'Fragile') {
        expandedValues.add('Fragile');
        expandedValues.add('Stable');
      } else if (value === 'Stable') {
        expandedValues.add('Stable');
      } else {
        expandedValues.add(value);
      }
    });
    
    return Array.from(expandedValues);
  }
  
  // Handle standard hierarchical categories (Low/Medium/High)
  if (!HIERARCHICAL_CATEGORIES.includes(category)) {
    return selectedValues; // Return as-is for non-hierarchical categories
  }
  
  const hierarchy = ['Low', 'Medium', 'High'];
  const expandedValues = new Set();
  
  selectedValues.forEach(value => {
    const valueIndex = hierarchy.indexOf(value);
    if (valueIndex !== -1) {
      // Add the selected value and all lower values
      for (let i = 0; i <= valueIndex; i++) {
        expandedValues.add(hierarchy[i]);
      }
    } else {
      // For non-hierarchical values within hierarchical categories, add as-is
      expandedValues.add(value);
    }
  });
  
  return Array.from(expandedValues);
}

// Initialize the application when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
  loadMethodsData();
  setupEventListeners();
});

// Function to load methods data from JSON
async function loadMethodsData() {
  try {
    // Fetch the methodologies.json file generated by your GitHub workflow
    const response = await fetch('./methodologies.json');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Parse the JSON response
    const jsonData = await response.json();
    
    // Store the data in state
    state.methodsData = jsonData;
    
    // Store the categories for easy access
    state.categories = jsonData.categories;
    
    // Initialize the UI with the loaded data
    initializeUI();
    
    console.log('Methods data loaded successfully:', {
      categories: jsonData.categories.length,
      methods: jsonData.methods.length
    });
    
  } catch (error) {
    console.error('There was a problem loading the methods data:', error);
    
    // Display user-friendly error message
    document.body.innerHTML = `
      <div class="container" style="text-align: center; padding: 50px;">
        <h2>Error Loading Data</h2>
        <p>There was a problem loading the methodology data.</p>
        <p>Please ensure that:</p>
        <ul style="text-align: left; max-width: 600px; margin: 0 auto;">
          <li>The GitHub workflow has run successfully</li>
          <li>The methodologies.json file exists in the repository</li>
          <li>The file is properly formatted JSON</li>
        </ul>
        <p><strong>Error details:</strong> ${error.message}</p>
        <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 20px;">
          Try Again
        </button>
      </div>
    `;
  }
}

// Function to initialize the UI with the loaded data
function initializeUI() {
  // Set up the steps content
  setupStepContent();
  
  // Start at Step 1
  navigateToStep(1);
}

// Function to set up the content for each step
function setupStepContent() {
  // Create category selection steps based on category groups
  const categoryGroups = groupCategoriesByTheme();
  
  // Clear existing step content containers except the first (template)
  const stepContainer = document.querySelector('.container');
  const progressBar = document.querySelector('.progress-bar');
  
  // Remove existing step content divs (except step1 which we'll repurpose)
  document.querySelectorAll('.step-content').forEach((step, index) => {
      if (index > 0) { // Keep the first step as a template
          step.remove();
      }
  });
  
  // Remove existing progress steps (except the first one)
  document.querySelectorAll('.progress-step').forEach((step, index) => {
      if (index > 0) { // Keep the first step as a template
          step.remove();
      }
  });
  
  // Update the first progress step
  const firstProgressStep = document.getElementById('step1-progress');
  firstProgressStep.querySelector('span').textContent = categoryGroups[0].name;
  
  // Add progress steps for each category group
  for (let i = 1; i < categoryGroups.length; i++) {
      const progressStep = document.createElement('div');
      progressStep.className = 'progress-step';
      progressStep.id = `step${i+1}-progress`;
      progressStep.innerHTML = `
          <div class="progress-circle">${i+1}</div>
          <span>${categoryGroups[i].name}</span>
      `;
      progressBar.appendChild(progressStep);
  }
  
  // Add a results step
  const resultsProgressStep = document.createElement('div');
  resultsProgressStep.className = 'progress-step';
  resultsProgressStep.id = `step${categoryGroups.length+1}-progress`;
  resultsProgressStep.innerHTML = `
      <div class="progress-circle">${categoryGroups.length+1}</div>
      <span>Results</span>
  `;
  progressBar.appendChild(resultsProgressStep);
  
  // Update the first step content
  updateStepContent(1, categoryGroups[0]);
  
  // Create step content divs for each category group
  for (let i = 1; i < categoryGroups.length; i++) {
      createStepContent(i+1, categoryGroups[i]);
  }
  
  // Create the results step
  createResultsStep(categoryGroups.length+1);
}

// Function to group categories by theme
function groupCategoriesByTheme() {
  // You can customize this grouping based on your needs
  return [
      {
          name: "Socio-Ecological Model Level",
          categories: [state.categories.find(cat => cat.id === "sem_level")]
      },
      {
          name: "Context of the Project Operating Environment",
          categories: [
              state.categories.find(cat => cat.id === "level_of_political_stability"),
              state.categories.find(cat => cat.id === "level_of_cultural_permissiveness"),
              state.categories.find(cat => cat.id === "political_sensitivity_regarding_empowerment_of_adolescent_girls"),
              state.categories.find(cat => cat.id === "participant_access_to_technology")
          ]
      },
      {
          name: "Project Resources",
          categories: [
              state.categories.find(cat => cat.id === "financial_resource"),
              state.categories.find(cat => cat.id === "human_resource_skills")
          ]
      }
  ];
}

// Function to update the content of the first step
function updateStepContent(stepNumber, group) {
  const stepContent = document.getElementById(`step${stepNumber}`);
  const stepCard = stepContent.querySelector('.card');
  
  // Update the step title
  stepCard.querySelector('h2').textContent = `Select ${group.name}`;
  
  // Clear existing content
  const optionsGrid = document.createElement('div');
  optionsGrid.className = 'options-container';
  
  // Create options for each category in this group
  group.categories.forEach(category => {
      const categorySection = document.createElement('div');
      categorySection.className = 'category-section';
      
      // Add hierarchical indicator if applicable
      const isHierarchical = HIERARCHICAL_CATEGORIES.includes(category.id) || category.id === POLITICAL_STABILITY_CATEGORY;
      let hierarchicalIndicator = '';
      
      if (category.id === POLITICAL_STABILITY_CATEGORY) {
        hierarchicalIndicator = '<span class="hierarchical-indicator" title="Conflict-affected includes Fragile and Stable; Fragile includes Stable">üèõÔ∏è Hierarchical</span>';
      } else if (isHierarchical) {
        hierarchicalIndicator = '<span class="hierarchical-indicator" title="Selecting High includes Medium and Low">üìä Hierarchical</span>';
      }
      
      categorySection.innerHTML = `
          <div class="category-header">
            <h3>${category.name} ${hierarchicalIndicator}</h3>
            <button class="select-all-btn" data-category-id="${category.id}">Select All</button>
          </div>
          <div class="checkbox-grid" data-category-id="${category.id}"></div>
      `;
      
      const checkboxGrid = categorySection.querySelector('.checkbox-grid');
      
      // Create checkboxes for each option
      category.options.forEach(option => {
          const checkboxItem = document.createElement('div');
          checkboxItem.className = 'checkbox-item';
          checkboxItem.innerHTML = `
              <label>
                  <input type="checkbox" data-category="${category.id}" data-option="${option}">
                  <span>${option}</span>
              </label>
          `;
          
          checkboxGrid.appendChild(checkboxItem);
      });
      
      optionsGrid.appendChild(categorySection);
  });
  
  // Replace existing options grid
  const existingGrid = stepCard.querySelector('.options-container');
  if (existingGrid) {
      stepCard.replaceChild(optionsGrid, existingGrid);
  } else {
      // Replace the paragraph and options-grid with our new content
      const paragraph = stepCard.querySelector('p');
      stepCard.insertBefore(optionsGrid, paragraph.nextSibling);
  }
  
  // Update the buttons
  const buttonsDiv = stepContent.querySelector('.buttons');
  buttonsDiv.innerHTML = '';
  
  // Add reset button
  const resetButton = document.createElement('button');
  resetButton.className = 'secondary';
  resetButton.id = `reset-step${stepNumber}`;
  resetButton.textContent = 'Reset Selections';
  resetButton.addEventListener('click', () => resetStepSelections(stepNumber));
  buttonsDiv.appendChild(resetButton);
  
  // Add back button if not the first step
  if (stepNumber > 1) {
      const backButton = document.createElement('button');
      backButton.className = 'secondary';
      backButton.id = `back-step${stepNumber}`;
      backButton.textContent = 'Back';
      backButton.addEventListener('click', () => navigateToStep(stepNumber - 1));
      buttonsDiv.appendChild(backButton);
  }
  
  // Add next button
  const nextButton = document.createElement('button');
  nextButton.id = `next-step${stepNumber}`;
  nextButton.textContent = 'Next';
  nextButton.addEventListener('click', () => navigateToStep(stepNumber + 1));
  buttonsDiv.appendChild(nextButton);
  
  // Set up event listeners for checkboxes
  stepContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', handleCheckboxChange);
  });
  stepContent.querySelectorAll('.select-all-btn').forEach(button => {
    button.addEventListener('click', handleSelectAllClick);
  });
}

// Function to create a new step content
function createStepContent(stepNumber, group) {
  const container = document.querySelector('.container');
  
  // Create step content div
  const stepContent = document.createElement('div');
  stepContent.className = 'step-content';
  stepContent.id = `step${stepNumber}`;
  
  // Create card
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
      <h2>Select ${group.name}</h2>
      <p>Choose options that match your requirements:</p>
  `;
  
  // Create options container
  const optionsContainer = document.createElement('div');
  optionsContainer.className = 'options-container';
  
  // Create options for each category in this group
  group.categories.forEach(category => {
      const categorySection = document.createElement('div');
      categorySection.className = 'category-section';
      
      // Add hierarchical indicator if applicable
      const isHierarchical = HIERARCHICAL_CATEGORIES.includes(category.id) || category.id === POLITICAL_STABILITY_CATEGORY;
      let hierarchicalIndicator = '';
      
      if (category.id === POLITICAL_STABILITY_CATEGORY) {
        hierarchicalIndicator = '<span class="hierarchical-indicator" title="Conflict-affected includes Fragile and Stable; Fragile includes Stable">üèõÔ∏è Hierarchical</span>';
      } else if (isHierarchical) {
        hierarchicalIndicator = '<span class="hierarchical-indicator" title="Selecting High includes Medium and Low">üìä Hierarchical</span>';
      }
      
      categorySection.innerHTML = `
          <div class="category-header">
              <h3>${category.name} ${hierarchicalIndicator}</h3>
              <button class="select-all-btn" data-category-id="${category.id}">Select All</button>
          </div>
          <div class="checkbox-grid" data-category-id="${category.id}"></div>
      `;
      
      const checkboxGrid = categorySection.querySelector('.checkbox-grid');
      
      // Create checkboxes for each option
      category.options.forEach(option => {
          const checkboxItem = document.createElement('div');
          checkboxItem.className = 'checkbox-item';
          checkboxItem.innerHTML = `
              <label>
                  <input type="checkbox" data-category="${category.id}" data-option="${option}">
                  <span>${option}</span>
              </label>
          `;
          
          checkboxGrid.appendChild(checkboxItem);
      });
      
      optionsContainer.appendChild(categorySection);
  });
  
  card.appendChild(optionsContainer);
  stepContent.appendChild(card);
  
  // Create buttons
  const buttonsDiv = document.createElement('div');
  buttonsDiv.className = 'buttons';
  
  // Add reset button
  const resetButton = document.createElement('button');
  resetButton.className = 'secondary';
  resetButton.id = `reset-step${stepNumber}`;
  resetButton.textContent = 'Reset Selections';
  resetButton.addEventListener('click', () => resetStepSelections(stepNumber));
  buttonsDiv.appendChild(resetButton);
  
  // Add back button
  const backButton = document.createElement('button');
  backButton.className = 'secondary';
  backButton.id = `back-step${stepNumber}`;
  backButton.textContent = 'Back';
  backButton.addEventListener('click', () => navigateToStep(stepNumber - 1));
  buttonsDiv.appendChild(backButton);
  
  // Add next button
  const nextButton = document.createElement('button');
  nextButton.id = `next-step${stepNumber}`;
  nextButton.textContent = 'Next';
  nextButton.addEventListener('click', () => navigateToStep(stepNumber + 1));
  buttonsDiv.appendChild(nextButton);
  
  stepContent.appendChild(buttonsDiv);
  container.appendChild(stepContent);
  
  // Set up event listeners for checkboxes
  stepContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', handleCheckboxChange);
  });
  stepContent.querySelectorAll('.select-all-btn').forEach(button => {
    button.addEventListener('click', handleSelectAllClick);
  });
}

// Select all functions
// Function to handle select all button clicks
function handleSelectAllClick(event) {
  const button = event.target;
  const categoryId = button.dataset.categoryId;
  const categorySection = button.closest('.category-section');
  const checkboxes = categorySection.querySelectorAll('input[type="checkbox"]');
  
  // Check if all checkboxes are currently selected
  const allSelected = Array.from(checkboxes).every(checkbox => checkbox.checked);
  
  if (allSelected) {
    // Deselect all
    checkboxes.forEach(checkbox => {
      if (checkbox.checked) {
        checkbox.checked = false;
        // Trigger change event to update state
        checkbox.dispatchEvent(new Event('change'));
      }
    });
    button.textContent = 'Select All';
    button.classList.remove('deselect');
  } else {
    // Select all
    checkboxes.forEach(checkbox => {
      if (!checkbox.checked) {
        checkbox.checked = true;
        // Trigger change event to update state
        checkbox.dispatchEvent(new Event('change'));
      }
    });
    button.textContent = 'Deselect All';
    button.classList.add('deselect');
  }
}

// Function to update select all button state
function updateSelectAllButtonState(categoryId) {
  const button = document.querySelector(`.select-all-btn[data-category-id="${categoryId}"]`);
  if (!button) return;
  
  const categorySection = button.closest('.category-section');
  const checkboxes = categorySection.querySelectorAll('input[type="checkbox"]');
  const checkedBoxes = categorySection.querySelectorAll('input[type="checkbox"]:checked');
  
  if (checkedBoxes.length === checkboxes.length && checkboxes.length > 0) {
    button.textContent = 'Deselect All';
    button.classList.add('deselect');
  } else {
    button.textContent = 'Select All';
    button.classList.remove('deselect');
  }
}

// Function to create the results step
function createResultsStep(stepNumber) {
  const container = document.querySelector('.container');
  
  // Create step content div
  const stepContent = document.createElement('div');
  stepContent.className = 'step-content';
  stepContent.id = `step${stepNumber}`;
  
  // Create card
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
      <h2>Matching Methodologies</h2>
      <p>Based on your selections, these methodologies are recommended:</p>
      <div id="results-container" class="results-container">
          <div class="no-results">No matching methodologies found. Try adjusting your selections.</div>
      </div>
  `;
  
  stepContent.appendChild(card);
  
  // Create buttons
  const buttonsDiv = document.createElement('div');
  buttonsDiv.className = 'buttons';
  
  // Add back button
  const backButton = document.createElement('button');
  backButton.className = 'secondary';
  backButton.id = `back-step${stepNumber}`;
  backButton.textContent = 'Back';
  backButton.addEventListener('click', () => navigateToStep(stepNumber - 1));
  buttonsDiv.appendChild(backButton);
  
  // Add start over button
  const startOverButton = document.createElement('button');
  startOverButton.className = 'secondary';
  startOverButton.id = 'start-over';
  startOverButton.textContent = 'Start Over';
  startOverButton.addEventListener('click', () => {
      resetAllSelections();
      navigateToStep(1);
  });
  buttonsDiv.appendChild(startOverButton);
  
  // Add download results button
  const downloadButton = document.createElement('button');
  downloadButton.id = 'download-results';
  downloadButton.textContent = 'Download Results';
  downloadButton.addEventListener('click', downloadResults);
  buttonsDiv.appendChild(downloadButton);
  
  stepContent.appendChild(buttonsDiv);
  container.appendChild(stepContent);
}

// Function to handle checkbox changes
function handleCheckboxChange(event) {
  const checkbox = event.target;
  const category = checkbox.dataset.category;
  const option = checkbox.dataset.option;
  
  // Initialize category in userSelections if it doesn't exist
  if (!state.userSelections[category]) {
      state.userSelections[category] = [];
  }
  
  if (checkbox.checked) {
      // Add the option to the user selections
      if (!state.userSelections[category].includes(option)) {
          state.userSelections[category].push(option);
      }
  } else {
      // Remove the option from the user selections
      state.userSelections[category] = state.userSelections[category].filter(item => item !== option);
      
      // Remove the category if it's empty
      if (state.userSelections[category].length === 0) {
          delete state.userSelections[category];
      }
  }
  
  // Update the filtered methods
  updateFilteredMethods();
  updateSelectAllButtonState(category);
}

// MODIFIED FUNCTION: Function to update filtered methods based on user selections with hierarchical filtering
function updateFilteredMethods() {
  // Start with all methods
  state.filteredMethods = [...state.methodsData.methods];
  
  // Filter based on user selections
  for (const category in state.userSelections) {
      const selectedOptions = state.userSelections[category];
      
      if (selectedOptions.length > 0) {
          // Apply hierarchical logic for hierarchical categories
          const expandedOptions = getHierarchicalValues(category, selectedOptions);
          
          state.filteredMethods = state.filteredMethods.filter(method => {
              // Check if the method has this category
              if (!method.attributes[category]) {
                  return false;
              }
              
              // Check if any of the expanded options match the method's attributes
              return expandedOptions.some(option => 
                  method.attributes[category].includes(option)
              );
          });
      }
  }
  
  // Update the results container if we're on the results step
  const resultsContainer = document.getElementById('results-container');
  if (resultsContainer) {
      updateResultsDisplay();
  }
}

// Function to update the results display
function updateResultsDisplay() {
  const resultsContainer = document.getElementById('results-container');
  resultsContainer.innerHTML = '';
  
  if (state.filteredMethods.length === 0) {
      // No results
      resultsContainer.innerHTML = `
          <div class="no-results">No matching methodologies found. Try adjusting your selections.</div>
      `;
  } else {
      // Create a card for each method
      state.filteredMethods.forEach(method => {
          const methodCard = document.createElement('div');
          methodCard.className = 'methodology-card';
          
          // Create method header
          const header = document.createElement('div');
          header.className = 'methodology-header';
          header.innerHTML = `<h3>${method.name}</h3>`;
          
          // Create method details
          const details = document.createElement('div');
          details.className = 'methodology-details';
          details.innerHTML = `<p>${method.description}</p>`;
          
          // Create criteria grid
          const criteriaGrid = document.createElement('div');
          criteriaGrid.className = 'criteria-grid';
          
          // Add key attributes to the criteria grid
          const keyCategories = ['sem_level', 'validity', 'reliability', 'value_for_money', 'resource_requirement'];
          keyCategories.forEach(catId => {
              const category = state.categories.find(c => c.id === catId);
              if (category && method.attributes[catId]) {
                  const values = method.attributes[catId].join(', ');
                  criteriaGrid.innerHTML += `
                      <div class="criteria-item">
                          <div class="criteria-label">${category.name}</div>
                          <div class="criteria-value">${values}</div>
                      </div>
                  `;
              }
          });
          
          details.appendChild(criteriaGrid);
          
          // Add show more button
          const showMoreBtn = document.createElement('button');
          showMoreBtn.className = 'show-more-btn';
          showMoreBtn.textContent = 'Show All Attributes';
          showMoreBtn.addEventListener('click', () => {
              // Toggle between showing key attributes and all attributes
              if (showMoreBtn.textContent === 'Show All Attributes') {
                  showMoreBtn.textContent = 'Show Less';
                  criteriaGrid.innerHTML = ''; // Clear existing criteria
                  
                  // Add all attributes
                  for (const catId in method.attributes) {
                      const category = state.categories.find(c => c.id === catId);
                      if (category) {
                          const values = method.attributes[catId].join(', ');
                          criteriaGrid.innerHTML += `
                              <div class="criteria-item">
                                  <div class="criteria-label">${category.name}</div>
                                  <div class="criteria-value">${values}</div>
                              </div>
                          `;
                      }
                  }
              } else {
                  showMoreBtn.textContent = 'Show All Attributes';
                  criteriaGrid.innerHTML = ''; // Clear existing criteria
                  
                  // Add only key attributes
                  keyCategories.forEach(catId => {
                      const category = state.categories.find(c => c.id === catId);
                      if (category && method.attributes[catId]) {
                          const values = method.attributes[catId].join(', ');
                          criteriaGrid.innerHTML += `
                              <div class="criteria-item">
                                  <div class="criteria-label">${category.name}</div>
                                  <div class="criteria-value">${values}</div>
                              </div>
                          `;
                      }
                  });
              }
          });
          
          details.appendChild(showMoreBtn);
          
          // Add header and details to the card
          methodCard.appendChild(header);
          methodCard.appendChild(details);
          
          // Toggle details when clicking on the header
          header.addEventListener('click', function(e) {
              if (details.classList.contains('active')) {
                  details.classList.remove('active');
              } else {
                  // Close other open details
                  document.querySelectorAll('.methodology-details.active').forEach(detail => {
                      if (detail !== details) {
                          detail.classList.remove('active');
                      }
                  });
                  details.classList.add('active');
              }
          });
          
          resultsContainer.appendChild(methodCard);
      });
  }
}

// Function to navigate between steps
function navigateToStep(stepNumber) {
  // Update filtered methods before showing results
  if (document.getElementById(`step${stepNumber}`).querySelector('#results-container')) {
      updateFilteredMethods();
      updateResultsDisplay();
  }
  
  // Hide all steps
  document.querySelectorAll('.step-content').forEach(step => {
      step.classList.remove('active');
  });
  
  // Reset progress indicators
  document.querySelectorAll('.progress-step').forEach(step => {
      step.classList.remove('active');
      step.classList.remove('completed');
  });
  
  // Show the target step
  document.getElementById(`step${stepNumber}`).classList.add('active');
  
  // Update progress indicators
  for (let i = 1; i <= stepNumber; i++) {
      if (i === stepNumber) {
          document.getElementById(`step${i}-progress`).classList.add('active');
      } else {
          document.getElementById(`step${i}-progress`).classList.add('completed');
      }
  }
}

// Function to reset selections for a specific step
function resetStepSelections(stepNumber) {
  const stepContent = document.getElementById(`step${stepNumber}`);
  
  // Uncheck all checkboxes in this step
  stepContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.checked = false;
      
      // Remove from user selections
      const category = checkbox.dataset.category;
      const option = checkbox.dataset.option;
      
      if (state.userSelections[category]) {
          state.userSelections[category] = state.userSelections[category].filter(item => item !== option);
          
          // Remove the category if it's empty
          if (state.userSelections[category].length === 0) {
              delete state.userSelections[category];
          }
      }
  });
  
  // Update filtered methods
  updateFilteredMethods();
  stepContent.querySelectorAll('.select-all-btn').forEach(button => {
      button.textContent = 'Select All';
      button.classList.remove('deselect');
  });
}

// Function to reset all selections
function resetAllSelections() {
  // Reset user selections
  state.userSelections = {};
  
  // Uncheck all checkboxes
  document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.checked = false;
  });
  
  // Reset filtered methods
  updateFilteredMethods();
}

// Function to download results
function downloadResults() {
  if (state.filteredMethods.length === 0) {
      alert('No methodologies to download. Please adjust your selections.');
      return;
  }
  
  // Create HTML content for the download
  let htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
          <title>Research Methodology Selection Results</title>
          <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
              h1, h2, h3 { color: #00629B; }
              .selection-summary { margin-bottom: 20px; }
              .method-card { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 5px; }
              .method-card h3 { margin-top: 0; color: #00629B; }
              .attributes-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; margin-top: 15px; }
              .attribute-item { background-color: #f5f5f5; padding: 8px; border-radius: 3px; }
              .attribute-name { font-weight: bold; }
              .hierarchical-note { background-color: #e7f3ff; padding: 10px; border-left: 4px solid #5b92e5; margin-bottom: 20px; }
          </style>
      </head>
      <body>
          <h1>Research Methodology Selection Results</h1>
          <div class="hierarchical-note">
              <strong>Note:</strong> For certain categories, selections are hierarchical:
              <ul>
                <li><strong>Cultural Permissiveness, Political Sensitivity, Technology Access, Financial Resources, Human Skills:</strong> Selecting "High" includes "Medium" and "Low" options</li>
                <li><strong>Political Stability:</strong> Selecting "Conflict-affected" includes "Fragile" and "Stable"; selecting "Fragile" includes "Stable"</li>
              </ul>
          </div>
          <div class="selection-summary">
              <h2>Your Selection Criteria</h2>
  `;
  
  // Add user selections
  for (const category in state.userSelections) {
      const categoryObj = state.categories.find(c => c.id === category);
      if (categoryObj) {
          const isHierarchical = HIERARCHICAL_CATEGORIES.includes(category) || category === POLITICAL_STABILITY_CATEGORY;
          let hierarchicalNote = '';
          
          if (category === POLITICAL_STABILITY_CATEGORY) {
            hierarchicalNote = ' (Political Stability - Hierarchical)';
          } else if (isHierarchical) {
            hierarchicalNote = ' (Hierarchical)';
          }
          
          const expandedOptions = getHierarchicalValues(category, state.userSelections[category]);
          const displayOptions = isHierarchical && state.userSelections[category].length !== expandedOptions.length ? 
            `${state.userSelections[category].join(', ')} ‚Üí ${expandedOptions.join(', ')}` : 
            state.userSelections[category].join(', ');
          htmlContent += `<p><strong>${categoryObj.name}${hierarchicalNote}:</strong> ${displayOptions}</p>`;
      }
  }
  
  // Add methods
  htmlContent += `
          </div>
          <h2>Matching Methodologies (${state.filteredMethods.length})</h2>
  `;
  
  state.filteredMethods.forEach(method => {
      htmlContent += `
          <div class="method-card">
              <h3>${method.name}</h3>
              <p>${method.description}</p>
              <div class="attributes-grid">
      `;
      
      // Add all attributes
      for (const catId in method.attributes) {
          const category = state.categories.find(c => c.id === catId);
          if (category) {
              const values = method.attributes[catId].join(', ');
              htmlContent += `
                  <div class="attribute-item">
                      <div class="attribute-name">${category.name}</div>
                      <div class="attribute-value">${values}</div>
                  </div>
              `;
          }
      }
      
      htmlContent += `
              </div>
          </div>
      `;
  });
  
  htmlContent += `
      </body>
      </html>
  `;
  
  // Create a download link
  const blob = new Blob([htmlContent], { type: 'text/html' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `methodology-selection-results-${new Date().toISOString().split('T')[0]}.html`;
  link.click();
}

// Function to set up event listeners
function setupEventListeners() {
  // Help button
  document.getElementById('help-btn').addEventListener('click', function() {
      document.getElementById('help-modal').style.display = 'block';
  });
  
  // Close help modal
  document.getElementById('close-help').addEventListener('click', function() {
      document.getElementById('help-modal').style.display = 'none';
  });
  
  // Close modals when clicking outside
  window.addEventListener('click', function(event) {
      const helpModal = document.getElementById('help-modal');
      
      if (event.target === helpModal) {
          helpModal.style.display = 'none';
      }
  });
}